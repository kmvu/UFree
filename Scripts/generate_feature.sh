#!/bin/bash

# Feature Generator Script
# Usage: ./generate_feature.sh "FeatureName" [uikit|swiftui]
# Example: ./generate_feature.sh "UserProfile" swiftui

set -e

FEATURE_NAME="${1}"
UI_FLAVOR="${2:-uikit}"
FEATURE_NAME_LOWER=$(echo "$FEATURE_NAME" | tr '[:upper:]' '[:lower:]')
FEATURE_NAME_CAMEL=$(echo "$FEATURE_NAME" | sed 's/^./\L&/')
FEATURE_NAME_UPPER=$(echo "$FEATURE_NAME" | tr '[:lower:]' '[:upper:]')

if [ -z "$FEATURE_NAME" ]; then
    echo "‚ùå Error: Feature name is required"
    echo "Usage: ./generate_feature.sh \"FeatureName\" [uikit|swiftui]"
    exit 1
fi

if [[ "$UI_FLAVOR" != "uikit" && "$UI_FLAVOR" != "swiftui" ]]; then
    echo "‚ùå Error: UI flavor must be either 'uikit' or 'swiftui'"
    echo "Usage: ./generate_feature.sh \"FeatureName\" [uikit|swiftui]"
    exit 1
fi

FEATURE_DIR="Features/$FEATURE_NAME"
TEST_DIR="Tests/Features/$FEATURE_NAME"

echo "üé® Generating $FEATURE_NAME feature (UI: $UI_FLAVOR)..."

# Create directories
mkdir -p "$FEATURE_DIR/Domain"
mkdir -p "$FEATURE_DIR/Data/Remote"
mkdir -p "$FEATURE_DIR/Data/Local"
mkdir -p "$FEATURE_DIR/Presentation"
mkdir -p "$FEATURE_DIR/UI"
mkdir -p "$TEST_DIR"

# Generate Domain Model
cat > "$FEATURE_DIR/Domain/${FEATURE_NAME}Model.swift" << EOF
//
//  ${FEATURE_NAME}Model.swift
//  Generated by Clean Architecture Template
//

import Foundation

public struct ${FEATURE_NAME}: Hashable, Identifiable {
    public let id: UUID
    
    public init(id: UUID) {
        self.id = id
    }
}
EOF

# Generate Loader Protocol
cat > "$FEATURE_DIR/Domain/${FEATURE_NAME}Loader.swift" << EOF
//
//  ${FEATURE_NAME}Loader.swift
//  Generated by Clean Architecture Template
//

import Foundation
import Combine

public protocol ${FEATURE_NAME}Loader {
    func load() -> AnyPublisher<${FEATURE_NAME}, Error>
}
EOF

# Generate API Protocol
cat > "$FEATURE_DIR/Data/Remote/${FEATURE_NAME}API.swift" << EOF
//
//  ${FEATURE_NAME}API.swift
//  Generated by Clean Architecture Template
//

import Foundation
import Combine

public protocol ${FEATURE_NAME}API {
    func load${FEATURE_NAME}() -> AnyPublisher<${FEATURE_NAME}, Error>
}
EOF

# Generate API Mapper
cat > "$FEATURE_DIR/Data/Remote/${FEATURE_NAME}Mapper.swift" << EOF
//
//  ${FEATURE_NAME}Mapper.swift
//  Generated by Clean Architecture Template
//

import Foundation

public enum ${FEATURE_NAME}Mapper {
    public static func map(_ data: Data, from response: HTTPURLResponse) throws -> ${FEATURE_NAME} {
        guard response.statusCode == 200 else {
            throw ${FEATURE_NAME}Mapper.Error.invalidData
        }
        
        // TODO: Implement JSON decoding
        // let json = try JSONDecoder().decode(Remote${FEATURE_NAME}.self, from: data)
        // return json.toModel()
        
        throw ${FEATURE_NAME}Mapper.Error.notImplemented
    }
    
    enum Error: Swift.Error {
        case invalidData
        case notImplemented
    }
}
EOF

# Generate Store Protocol
cat > "$FEATURE_DIR/Data/Local/${FEATURE_NAME}Store.swift" << EOF
//
//  ${FEATURE_NAME}Store.swift
//  Generated by Clean Architecture Template
//

import Foundation

public protocol ${FEATURE_NAME}Store {
    func save(_ ${FEATURE_NAME_CAMEL}: ${FEATURE_NAME}) throws
    func load() throws -> ${FEATURE_NAME}?
    func delete() throws
}
EOF

# Generate Local Model
cat > "$FEATURE_DIR/Data/Local/Local${FEATURE_NAME}Model.swift" << EOF
//
//  Local${FEATURE_NAME}Model.swift
//  Generated by Clean Architecture Template
//

import Foundation

public struct Local${FEATURE_NAME}: Codable {
    public let id: UUID
    
    public init(id: UUID) {
        self.id = id
    }
}

extension Local${FEATURE_NAME} {
    func toModel() -> ${FEATURE_NAME} {
        ${FEATURE_NAME}(id: id)
    }
}

extension ${FEATURE_NAME} {
    func toLocal() -> Local${FEATURE_NAME} {
        Local${FEATURE_NAME}(id: id)
    }
}
EOF

# Generate Presenter
cat > "$FEATURE_DIR/Presentation/${FEATURE_NAME}Presenter.swift" << EOF
//
//  ${FEATURE_NAME}Presenter.swift
//  Generated by Clean Architecture Template
//

import Foundation

public final class ${FEATURE_NAME}Presenter {
    public static var title: String {
        NSLocalizedString(
            "${FEATURE_NAME_UPPER}_VIEW_TITLE",
            tableName: "${FEATURE_NAME}",
            bundle: Bundle(for: ${FEATURE_NAME}Presenter.self),
            comment: "Title for the ${FEATURE_NAME_LOWER} view"
        )
    }
    
    public static func map(_ ${FEATURE_NAME_CAMEL}: ${FEATURE_NAME}) -> ${FEATURE_NAME}ViewModel {
        ${FEATURE_NAME}ViewModel(id: ${FEATURE_NAME_CAMEL}.id)
    }
}
EOF

# Generate ViewModel
cat > "$FEATURE_DIR/Presentation/${FEATURE_NAME}ViewModel.swift" << EOF
//
//  ${FEATURE_NAME}ViewModel.swift
//  Generated by Clean Architecture Template
//

import Foundation

public struct ${FEATURE_NAME}ViewModel: Identifiable, Hashable {
    public let id: UUID
    
    public init(id: UUID) {
        self.id = id
    }
}
EOF

if [ "$UI_FLAVOR" == "uikit" ]; then

# Generate View Adapter (UIKit)
cat > "$FEATURE_DIR/UI/${FEATURE_NAME}ViewAdapter.swift" << EOF
//
//  ${FEATURE_NAME}ViewAdapter.swift
//  Generated by Clean Architecture Template (UIKit)
//

import UIKit
import Core

@MainActor
final class ${FEATURE_NAME}ViewAdapter: ResourceView {
    private weak var controller: ListViewController?
    
    init(controller: ListViewController) {
        self.controller = controller
    }
    
    func display(_ viewModel: ${FEATURE_NAME}ViewModel) {
        // TODO: Implement view model display logic
        // controller?.display([CellController(id: viewModel.id, ...)])
    }
}
EOF

# Generate Composer (UIKit)
cat > "$FEATURE_DIR/UI/${FEATURE_NAME}Composer.swift" << EOF
//
//  ${FEATURE_NAME}Composer.swift
//  Generated by Clean Architecture Template (UIKit)
//

import UIKit
import Combine
import Core

@MainActor
public final class ${FEATURE_NAME}Composer {
    private init() {}
    
    private typealias ${FEATURE_NAME}PresentationAdapter = LoadResourcePresentationAdapter<${FEATURE_NAME}, ${FEATURE_NAME}ViewAdapter>
    
    public static func ${FEATURE_NAME_CAMEL}ComposedWith(
        loader: @escaping () -> AnyPublisher<${FEATURE_NAME}, Error>
    ) -> ListViewController {
        let presentationAdapter = ${FEATURE_NAME}PresentationAdapter(loader: loader)
        
        let controller = make${FEATURE_NAME}ViewController(title: ${FEATURE_NAME}Presenter.title)
        controller.onRefresh = presentationAdapter.loadResource
        
        presentationAdapter.presenter = LoadResourcePresenter(
            resourceView: ${FEATURE_NAME}ViewAdapter(controller: controller),
            loadingView: WeakRefVirtualProxy(controller),
            errorView: WeakRefVirtualProxy(controller),
            mapper: ${FEATURE_NAME}Presenter.map)
        
        return controller
    }
    
    private static func make${FEATURE_NAME}ViewController(title: String) -> ListViewController {
        let controller = ListViewController()
        controller.title = title
        return controller
    }
}
EOF

else

# Generate SwiftUI ViewModel
cat > "$FEATURE_DIR/UI/${FEATURE_NAME}ViewModel.swift" << EOF
//
//  ${FEATURE_NAME}ViewModel.swift
//  Generated by Clean Architecture Template (SwiftUI)
//

import Foundation
import Combine

@MainActor
final class ${FEATURE_NAME}ViewModel: ObservableObject {
    @Published var items: [${FEATURE_NAME}ViewModelItem] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let loader: () -> AnyPublisher<${FEATURE_NAME}, Error>
    private var cancellables = Set<AnyCancellable>()
    
    init(loader: @escaping () -> AnyPublisher<${FEATURE_NAME}, Error>) {
        self.loader = loader
    }
    
    func load() {
        guard !isLoading else { return }
        isLoading = true
        errorMessage = nil
        
        loader()
            .map(${FEATURE_NAME}Presenter.map)
            .map { [${FEATURE_NAME}ViewModelItem(id: $0.id)] }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] completion in
                self?.isLoading = false
                if case let .failure(error) = completion {
                    self?.errorMessage = error.localizedDescription
                }
            }, receiveValue: { [weak self] items in
                self?.items = items
            })
            .store(in: &cancellables)
    }
}

struct ${FEATURE_NAME}ViewModelItem: Identifiable, Hashable {
    let id: UUID
}
EOF

# Generate SwiftUI View
cat > "$FEATURE_DIR/UI/${FEATURE_NAME}View.swift" << EOF
//
//  ${FEATURE_NAME}View.swift
//  Generated by Clean Architecture Template (SwiftUI)
//

import SwiftUI
import Core
import Combine

@MainActor
public struct ${FEATURE_NAME}View: View {
    @StateObject private var viewModel: ${FEATURE_NAME}ViewModel
    
    public init(viewModel: ${FEATURE_NAME}ViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
    }
    
    public var body: some View {
        NavigationStack {
            List(viewModel.items) { item in
                Text(item.id.uuidString)
            }
            .navigationTitle(${FEATURE_NAME}Presenter.title)
            .overlay(alignment: .top) {
                if let message = viewModel.errorMessage {
                    Text(message)
                        .foregroundColor(.white)
                        .padding(8)
                        .frame(maxWidth: .infinity)
                        .background(Color.red.opacity(0.8))
                }
            }
            .overlay {
                if viewModel.isLoading {
                    ProgressView().progressViewStyle(.circular)
                }
            }
            .refreshable {
                viewModel.load()
            }
            .task {
                viewModel.load()
            }
        }
    }
}
EOF

# Generate Composer (SwiftUI returns UIViewController for easy integration)
cat > "$FEATURE_DIR/UI/${FEATURE_NAME}Composer.swift" << EOF
//
//  ${FEATURE_NAME}Composer.swift
//  Generated by Clean Architecture Template (SwiftUI)
//

import UIKit
import SwiftUI
import Combine
import Core

@MainActor
public enum ${FEATURE_NAME}Composer {
    public static func ${FEATURE_NAME_CAMEL}ComposedWith(
        loader: @escaping () -> AnyPublisher<${FEATURE_NAME}, Error>
    ) -> UIViewController {
        let viewModel = ${FEATURE_NAME}ViewModel(loader: loader)
        let view = ${FEATURE_NAME}View(viewModel: viewModel)
        return UIHostingController(rootView: view)
    }
}
EOF

fi

# Generate Unit Tests
cat > "$TEST_DIR/${FEATURE_NAME}Tests.swift" << EOF
//
//  ${FEATURE_NAME}Tests.swift
//  Generated by Clean Architecture Template
//

import XCTest
import Foundation
@testable import ${FEATURE_NAME}

final class ${FEATURE_NAME}Tests: XCTestCase {
    
    func test_init_createsModelWithId() {
        let id = UUID()
        let sut = ${FEATURE_NAME}(id: id)
        
        XCTAssertEqual(sut.id, id)
    }
    
    func test_equality_comparesById() {
        let id = UUID()
        let sut1 = ${FEATURE_NAME}(id: id)
        let sut2 = ${FEATURE_NAME}(id: id)
        
        XCTAssertEqual(sut1, sut2)
    }
}
EOF

# Generate Presenter Tests
cat > "$TEST_DIR/${FEATURE_NAME}PresenterTests.swift" << EOF
//
//  ${FEATURE_NAME}PresenterTests.swift
//  Generated by Clean Architecture Template
//

import XCTest
import Foundation
@testable import ${FEATURE_NAME}

final class ${FEATURE_NAME}PresenterTests: XCTestCase {
    
    func test_map_createsViewModel() {
        let model = ${FEATURE_NAME}(id: UUID())
        let viewModel = ${FEATURE_NAME}Presenter.map(model)
        
        XCTAssertEqual(viewModel.id, model.id)
    }
}
EOF

# Generate Integration Tests
cat > "$TEST_DIR/${FEATURE_NAME}UIIntegrationTests.swift" << EOF
//
//  ${FEATURE_NAME}UIIntegrationTests.swift
//  Generated by Clean Architecture Template
//

import XCTest
import Combine
@testable import ${FEATURE_NAME}
@testable import Core

@MainActor
final class ${FEATURE_NAME}UIIntegrationTests: XCTestCase {
    
    func test_${FEATURE_NAME_LOWER}View_hasTitle() {
        let (sut, _) = makeSUT()
        
        XCTAssertEqual(sut.title, ${FEATURE_NAME}Presenter.title)
    }
    
    // MARK: - Helpers
    
    private func makeSUT(file: StaticString = #filePath, line: UInt = #line) -> (UIViewController, LoaderSpy) {
        let loader = LoaderSpy()
        let sut = ${FEATURE_NAME}Composer.${FEATURE_NAME_CAMEL}ComposedWith(loader: loader.loadPublisher)
        trackForMemoryLeaks(sut, file: file, line: line)
        trackForMemoryLeaks(loader, file: file, line: line)
        return (sut, loader)
    }
    
    @MainActor
    private class LoaderSpy {
        private var requests = [PassthroughSubject<${FEATURE_NAME}, Error>]()
        
        var loadCallCount: Int {
            return requests.count
        }
        
        func loadPublisher() -> AnyPublisher<${FEATURE_NAME}, Error> {
            let publisher = PassthroughSubject<${FEATURE_NAME}, Error>()
            requests.append(publisher)
            return publisher.eraseToAnyPublisher()
        }
        
        func completeLoading(with ${FEATURE_NAME_CAMEL}: ${FEATURE_NAME} = make${FEATURE_NAME}(), at index: Int = 0) {
            requests[index].send(${FEATURE_NAME_CAMEL})
            requests[index].send(completion: .finished)
        }
        
        func completeLoadingWithError(at index: Int = 0) {
            requests[index].send(completion: .failure(anyNSError()))
        }
    }
    
    private func make${FEATURE_NAME}() -> ${FEATURE_NAME} {
        ${FEATURE_NAME}(id: UUID())
    }
}
EOF

echo "‚úÖ Feature files generated"
echo ""
echo "üìù Generated files:"
echo "  Domain:"
echo "    - ${FEATURE_NAME}Model.swift"
echo "    - ${FEATURE_NAME}Loader.swift"
echo "  Data:"
echo "    - ${FEATURE_NAME}API.swift"
echo "    - ${FEATURE_NAME}Mapper.swift"
echo "    - ${FEATURE_NAME}Store.swift"
echo "    - Local${FEATURE_NAME}Model.swift"
echo "  Presentation:"
echo "    - ${FEATURE_NAME}Presenter.swift"
echo "    - ${FEATURE_NAME}ViewModel.swift"
echo "  UI (${UI_FLAVOR}):"
echo "    - ${FEATURE_NAME}ViewAdapter.swift (UIKit only)"
echo "    - ${FEATURE_NAME}Composer.swift"
echo "    - ${FEATURE_NAME}View.swift / ViewModel.swift (SwiftUI only)"
echo "  Tests:"
echo "    - ${FEATURE_NAME}Tests.swift"
echo "    - ${FEATURE_NAME}PresenterTests.swift"
echo "    - ${FEATURE_NAME}UIIntegrationTests.swift"
echo ""
echo "‚ú® Feature generation complete!"
echo ""
echo "Next steps:"
echo "1. Add files to Xcode project"
echo "2. Implement business logic"
echo "3. Connect to your API"
echo "4. Customize UI"
echo ""